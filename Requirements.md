# 需求分析与深度技术选型报告 (V2.0)

本报告基于初始需求进行深度细化，重点针对**数据库选型**、**现代化前端架构**、**项目潜在风险分析**及**未来扩展性**进行详细阐述。

## 1. 深度技术选型

### 1.1 数据库选型：PostgreSQL
针对本项目“视频流日志记录”与“人脸检索”的核心需求，强烈推荐使用 **PostgreSQL (15+)**。

*   **选型理由**：
    1.  **高并发写入能力**：监控系统会产生大量实时日志（每一帧陌生人抓拍都是一条记录），PG 在高并发写入下的稳定性优于 MySQL。
    2.  **复杂查询性能**：用户需要进行多维度的历史记录查询（时间段 + 地点 + 摄像头 + 人员类型），PG 的查询优化器非常强大。
    3.  **JSONB 支持**：视频分析产生的 metadata（如抓拍时的置信度、人脸框坐标、额外特征属性）结构可能变化，PG 的 JSONB 存储允许灵活扩展字段而无需频繁修改表结构。
    4.  **未来扩展 - 向量检索 (pgvector)**：这是最重要的一点。未来若需提升大规模人脸比对速度，PG 可以直接安装 `pgvector` 插件。
    5.  **灵活部署支持**：**完全支持非 Docker 部署**。
        *   **对于无网/内网环境**：可以直接下载 PostgreSQL 的二进制安装包（Windows `exe` / Linux `rpm` 或 `deb`）进行离线安装。
        *   **服务管理**：在 Linux 下通过 `systemd` 管理，在 Windows 下作为标准系统服务运行，无需容器运行时环境。

*   **ORM 框架推荐**：**SQLAlchemy (Async)**
    *   配合 FastAPI 实现全链路异步数据库操作，避免数据库 I/O 阻塞视频流处理线程。

### 1.2 前端架构：Vue 3 + 现代化审美
为了达成“现代化、简洁、美观”的视觉目标，我们摒弃传统的“管理后台风格”，采用更具设计感的 C 端产品思路。

*   **核心框架**：**Vue 3 (Composition API)** + **Vite**
*   **UI 设计体系 (这也是“美观”的关键)**：
    *   **首选方案：Shadcn-vue + TailwindCSS**
        *   **理由**：Shadcn 的 `Sonner` 或 `Toast` 组件非常适合实现您需要的报警效果。
        *   **报警交互重构**：根据您的需求，我们将摒弃传统的“弹窗(Modal)”，改为 **“持久化通知侧边栏 (Persistent Notification Feed)”**。
            *   **位置**：屏幕右侧边缘。
            *   **行为**：报警卡片会像消息流一样从右上角滑入并向下堆叠。
            *   **交互**：完全不遮挡主界面操作。用户可以选择手动点击“处理/忽略”来消除卡片，否则卡片会一直停留在右侧滚动列表中供随时查看。
        *   **样式库**：TailwindCSS 让我们能以原子化方式快速写出响应式布局。
    *   **备选方案：Naive UI**
        *   如果希望开箱即用但又不想像 Element Plus 那么“大众脸”，Naive UI 是非常优秀的选择，它的组件设计感更强，且原生支持深色模式。
*   **可视化图表**：**ECharts** (通过 `vue-echarts` 封装)
    *   用于仪表盘展示。建议重新配置 ECharts 的默认色盘，使用低饱和度配色以符合“现代化”审美。
*   **特效与动画**：**Framer Motion (Vue版)** 或 **VueUse** 的 Motion 模块
    *   在陌生人报警弹窗、列表加载时添加自然的过渡动画，极大提升“精致感”。

## 2. 项目深度分析与补充 (Insights)

基于对视频监控系统的开发经验，现有需求文档在以下几个**关键非功能性需求**上需要补充：

### 2.1 存储策略 (Storage Strategy)
*   **问题**：直接将图片（人脸截图、全景截图）存入数据库会迅速撑爆数据库，导致备份困难且读取缓慢。
*   **解决方案**：
    *   **文件系统/对象存储**：图片应存储在磁盘文件系统中（如 `/data/captures/YYYY/MM/DD/{uuid}.jpg`）或 MinIO 对象存储中。
    *   **数据库仅存路径**：PostgreSQL 中只保存图片的相对路径或 URL。
    *   **定期清理**：必须设计“过期数据自动清理”机制（如保留30天），否则磁盘空间会迅速耗尽（视频截图体积巨大）。

### 2.2 性能瓶颈与异步解耦 (Performance)
*   **风险**：人脸识别是非常消耗 CPU/GPU 的操作。如果直接在 API 线程或视频流读取线程中同步进行识别，会导致视频卡顿、掉帧。
*   **改进**：
    *   **生产者-消费者模型**：
        1.  **采集进程**：只负责读取 RTSP 流并解码，放入内存队列（Queue）。
        2.  **分析进程**：从队列取帧，进行人脸检测与识别（耗时操作）。
        3.  **结果推送**：识别结果通过 WebSocket 推送前端，并异步写入数据库。
    *   这样即使识别速度跟不上（如一秒只能识别5帧），也不会影响视频流的实时播放，只会造成报警延迟几百毫秒，这是可接受的。

### 2.3 弱网与异常处理
*   **断流重连**：RTSP 流经常会因为网络波动断开。系统必须具备**自动重连机制**，并在前端友好提示“信号丢失”，而不是直接白屏报错。

## 3. 扩展性设计 (Scalability)

为了应对未来可能的功能增加（如：不仅识别陌生人，还要识别打架、火灾，或者接入上百路摄像头），架构设计需预留接口：

### 3.1 模块化分析管道 (Pipeline Architecture)
不要将业务逻辑写死在一个函数里。设计一个 **Processor Pipeline** 模式：
*   `VideoFrame` -> `[FaceDetectNode]` -> `[FaceRecognizeNode]` -> `[ActionLogNode]` -> `Result`
*   **未来扩展**：如果以后要加“安全帽检测”，只需在管道中插入一个 `[HelmetDetectNode]`，完全不影响原有的人脸识别代码。

### 3.2 服务拆分准备
目前可能是单体应用（Monolith）。但建议代码结构上将 **Core Engine**（视频分析）与 **Web Server**（API/管理）逻辑上隔离。
*   未来如果需要扩展，可以将 Core Engine 部署在配有 GPU 的高性能服务器上，而 Web Server 部署在普通服务器上，两者通过 Redis 或 RPC 通信。

### 3.3 插件化报警动作
目前的报警是“弹窗”和“数据库记录”。
*   设计一个 **Action Interface**：未来可以轻松扩展为：发送短信、发送邮件、触发声光报警器（GPIO控制）、调用第三方 API 等，只需实现新的 Action 类。

## 总结：改进后的推荐开发路径
1.  **基础设施**：Docker (PostgreSQL) + Python 3.10 + Node.js 18+
2.  **后端**：FastAPI + SQLAlchemy + OpenCV + InsightFace (或 dlib) + **多进程架构**
3.  **前端**：Vue 3 + Vite + **Shadcn-vue (Tailwind)** + WebSocket
